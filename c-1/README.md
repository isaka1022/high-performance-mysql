# 1章 MySQLのアーキテクチャと歴史

- MySQLは他のデータベースサーバーとは違う
- アーキテクチャに特徴がある
- 柔軟
- MySQLの最も独特で重要な機能は、クエリ処理やその他のサーバータスクをデータの格納と取得から分離するように設計されたストレージエンジンアーキテクチャ

## 1.1 MySQLの論理アーキテクチャ

- 一番上のレイヤには接続処理/認証/セキュリティなどネットワークベースの殆どのクライアント/サーバーツールで必要となるサービス
- 2つめにはクリエ解析、分析、最適化、キャッシュ、組み込み関数、ストアドプロシージャ、トリガ、ビュー
- 3つめにはストレージエンジンが含まれる
    - MySQLの中に格納されているすべてのデータの保存と取得を受け持つ
    - サーバーはストレージエンジンAPIを通じてそれらとやりとりする
    - クエリレイヤでは見分けがつかなくなる

### 1.1.1 接続の管理とセキュリティ

- クライアント接続はそれぞれサーバープロセス内で独自のスレッドを取得する
- 接続のクエはその1つのスレッドで実行され、1つのコアまたはCPUと関連付けられる
- サーバーはスレッドをキャッシュする
    - 新しい接続のたびにスレッドの作成と削除を繰り返す必要はない
- クライアントがMySQLサーバーに接続するためにはサーバーが認証する必要がある
    - ユーザー名
    - 接続先ホスト
    - パスワード
    - SSL接続でX.509証明書を使用することもできる
    - クライアントが接続後に、サーバーはクライアントがworldデーターベースのCountryテーブルにSELECT文を送信する権限を持っているかどうかなど、クライアントがクエリに関する特権を持っているかどうかを確認する

### 1.1.2 最適化と実行

- MySQLはクエリを解析して内部構造を作成した後に、最適化を使用する
    - クエリの書き換え、テーブルを読み取る順序の決定、使用するインデックスの選択など
- クエリの特殊なキーワードを通じてオプティマイザにヒントを私、意思決定プロセスを反映させることもできる
- クエリ、スキーマ、設計を見直してすべてをできるだけ効率化するための基準点が得られる
- オプティマイザはどのテーブルがどのストレージエンジン使用するかについてはあまり関しがないが、ストレージエンジンはサーバーがクエリを最適化する方法に影響を与える
- オプティマイザはストレージエンジンの機能、特定の操作にかかるコスト、テーブルデータの統計をストレージエンジンに問い合わせる
- サーバーはクエリを解析する前であっても、SELECT文とそれらの結果セットだけが格納されるクエリキャッシュを調べる
- 送信されたクエリがすでにキャッシュに含まれるものと同じだった場合、キャッシュに格納されている結果セットを返すだけでよい

## 1.2 並行性の制御

- 複数のクエリがデータを同時に変更する必要が生じるたびに、並行性の制御が問題
- MySQLはサーバーレベルとストレージエンジンレベルの2つのレベルでそれを制御する必要がある

### 1.2.1 読み取り/書き込みロック

- 同時読み取り/書き込みアクセスに対処するシステムは2つの種類のロックシステムを実装する
    - 共有ロックと排他ロック、または読み取りロックと書き込みロック
- リソースの読み取りロックは共有されるまたは相互にノンブロッキング
    - 複数のクライアントがリソースを同時に読み取り、互いに干渉しない
- 書き込みロックは排他的
    - 読み取りロックと他の書き込みロックの両方をブロックする
- 常にリソースへの書き込みを行うクライアントを1つだけにし、書き込み中は読み取りを阻止するのが安全なポリシーだから

### 1.2.2 ロックの粒度

- 共有リソースの並行性を向上させる方法は、何をロックするかについて細かく選択する
    - 変更する必要があるデータが含まれている部分だけロック
    - 変更する予定のデータだけをロック
- ロックがリソースを消費する
    - ロックの取得
    - ロックが空いているかどうかのチェック
    - ロックの解除
- ロック戦略：ロックのオーバーヘッドとデータの安全性に折り合いをつけること
- ほとんどはテーブルでの行ロック
- MySQLは独自のロックポリシーとロック粒度を実装できる

**テーブルロック**

- 最も基本的で最もオーバーヘッドが低い
- テーブルに対して挿入、削除、更新などの書き込み操作を行いたいクライアントは書き込みロックを取得する
- 他の読み取り/書き込み操作はすべて拒否される
- 特定の状況でパフォーマンスを高めるバリエーション
    - READ LOCALテーブルロックは一種の同時書き込み操作を許可する
    - 書き込みロックは読み取りロックよりもキューの前方に配置される

**行ロック**

- 並行性、オーバーヘッドが最も高いロック方式
- InnoDBやXtraDBでも利用できる
- サーバーでなくてストレージエンジンで実装される
- サーバーはストレージエンジンで実装されるロックのことを何も知らない

## 1.2 トランザクション

- 1つの作業単位としてアトミックに扱われるSQLクエリの集まり
    - クエリ全体をデータベースに適用できる場合にはそうするが、クラッシュなどの理由で実行できないクエリがあればどのクエリも適用しない
- ACID
- アトミック姓
    - トランザクション全体が1つの分割できない作業単位として機能する
    - すべて完了するか、全て完了しないか
- 一貫性
    - 一つの一貫した状態から次の一貫した状態へ遷移すべき
- 分離性
    - トランザクションの結果はすべて完了するまで他のトランザクションからは見れない
- 永続性
    - コミットされたトランザクションの変更は確定される
    - 変更は記録される
- ACIDトランザクションに対応するデータベースサーバーはCPUパワー、メモリ、ディスク領域を必要とする
- 特定の種類のクエリにトランザクションに対応しないストレージエンジンを使用することでパフォーマンスを改善できるかもしれない

### 1.3.1 分離レベル

- SQL規格は4つの分離レベルを定義
- 分離レベルが低いほど並行性が高くなりオーバーヘッドが低くなる

**READ UNCOMMITTED**

- コミットされていないトランザクションの結果が他のトランザクションから見える
- いろいろな問題をはらんでいる
- 滅多に使われない
- ダーティリードとも呼ばれる

**READ COMMITED**

- ほとんどのRDBSのデフォルトの分離レベル
- トランザクションから見えるのはそれが開始された時にコミットされていたトランザクションによる変更だけ
- ノンリピータブルリードが許可
    - 同じステートメントを2回実行すると異なるデータが返される可能性がある

**REPEATABLE READ**

- トランザクションが読み取るすべての行が同じトランザクションのそれ以降の読み取りで同じに見えることが保証
- ファントムリードのも谷がある
    - ある範囲の行を選択した後、別のトランザクションがその範囲に新しい行を挿入し、その後に同じ範囲を再び選択したときに、新しい幻のファントムが現れる
- InnoDBとXtraDBはMVCCに基づいてファントムリードの問題を解決する
- MySQLのデフォルトのトランザクション分離レベルSERIALIZABLE

**SERIALIZABLE**

- 最も高いレベルの分離性
- 競合が怒らないようにトランザクションを強制的に順序付けて解決
- すべての読みとる行にロックを設定

### 1.3.2 デッドロック

- 複数のトランザクションが同じリソースのロックをめぐって競合し、それぞれのロックをリクエストして依存関係の循環を招くこと
- トランザクションが異なる順序でリソースをロックしようとしたとき
- InnoDBストレージエンジンなどの高度なシステムは循環依存を検知するとすぐにエラーを返す
- ロック待ちのタイムアウトが過ぎた時点でクエリの処理を断念しても、必ずしもよいとは限らない
- InnoDBは現在の排他ロックの数が最も少ないトランザクションをロールバックすることでデッドロックに対処している
- トランザクションを部分的または完全にロールバックしなければデッドロックは解除できない

### 1.3.3 トランザクションログ

- ストレージエンジンは変更が発生するたびにディスク上のテーブルを更新するのではなく、データのメモリ上のコピーを変更するだけでよい
- その後、ストレージエンジンの変更の記録をトランザクションログに書き込むことができる
    - ディスク上にあるため永続化できる
- ディスク上をあちこち飛び回るランダムI/Oではなく狭い範囲のシーケンシャルなI/Oが使用されるので、ログイベントの追加も比較的高速
- ログの先行書き込み
- トランザクションログに書き込まれたからデータ自体が変更されるまでの間にクラッシュしても、ストレージエンジンは再起動時に変更を取り戻すことができる

### 1.3.4 MySQLのトランザクション

- MySQLはInnoDBとNDB Clusterのトランザクショナルストレージエンジンを提供している

**AUTOCOMMIT**

- MySQLはデフォルトではAUTOCOMMIT
- クエリはそれぞれ別々のトランザクションで実行される
- AUTOCOMMITの値を変更しても、MyISAMやMemoryデーブルといった非トランザクショナルテーブルへの変更はない
- 実行中のトランザクションで発行するとMySQLがそのコマンドを実行する前にそのトランザクションをコミットするものがある
    - ALTER TABLEのような大幅な変更を行うDDL(Data Definition Language)コマンド
    - LOCK TABLE
- MySQLで分離レベルを設定するには`SET TRANSACTION ISOLATION LEVEL` コマンドを使用する

**トランザクションでの複数のストレージエンジンの併用**

- MySQLはトランザクションをサーバーレベルで管理しない
    - ストレージエンジンが管理
    - 複数のエンジンを1つのトランザクションで併用することが不可能
- トランザクショナルテーブルと非トランザクショナルテーブルがトランザクションに含まれている場合順当にいけばトランザクションは正常に処理される
- ロールバックが要求された場合、非トランザクショナルテーブルへの変更を取り消すことはできない
- MySQLは非トランザクショナルテーブルでトランザクション操作を行ったとしても通常は警告やエラーを生成しない

**暗黙的なロックと明示的なロック**

- InnoDBは2相のロックプロトコルを使用する
- トランザクションの実行中はいつでも使用できるが、`COMMIT`または`ROLLBACK`まで開放されない
- InnoDBはすべてのロックを同時に開放する
    - すべて暗黙的
    - 分離レベルに基づいてロックを自動的に処理する
- InnoDBは明示的なロックもサポート
    - SELECT ... LOCK IN SHARE MODE
    - SELECT ... FOR UPDATE
- ストレージエンジンではなくサーバー上で実装される
- MyISAMからInnoDBに変換されているものの依然としてLOCK TABLESを使用しているアプリケーションをよく見かける
    - 行レベルのロックなのでもはや不要で、パフォーマンスを劇的に低下させる可能性がある

## 1.4 マルチバージョンの並行性制御

- MySQLのトランザクショナルストレージエンジンの行レベルのロックとMVCCと呼ばれる並行性を高める手法を組み合わせて使用する
- MVCCでロックの必要性を完全に排除し、オーバーヘッドの多くを解消する可能性がある
    - ロックを使用しない読み取りを許可する一方で、書き込み操作では必要なレコードだけをロックする
- MVCCはある時点で存在していたデータのスナップショットを作成するという仕組みで動作する
    - トランザクションの長さに関わらず、参照できるデータは一貫
    - 複数のトランザクションが同じテーブル内にあの異なるデータを同時に参照することも意味する
- 楽観的（オプティミスティック）並行性制御と悲観的（ペシミスティック）並行性制御
- InnoDBによるMVCCの実装
    - 行ごとに隠れた値を2つ格納する
        - 行が生成されたタイミング
        - 行が期限切れになった（削除された）タイミング
    - 各イベントが発生された時刻ではなくシステムバージョンを記録
    - トランザクションは開始時点でのシステムバージョンを記録
    - SELECT
        - InnoDBは各行を調べて以下の2つの条件が満たされていることを確認
            - 少なくともトランザクションと同じかそれ以前のバージョンの行を検索しなければならない
            - 行の削除バージョンは未定義であるか、トランザクションのバージョンよりも新しいバージョンでなければならない
    - INSERT
        - 現在のシステムバージョンを新しい行に記録する
    - UPDATE
        - InnoDBは新しいバージョンに対応するシステムバージョン番号を使って新しいコピーを書き出す
        - 古い行の削除バージョンとしてシステムバージョン番号を書き出す
    - これらの追加レコードを記録すると、ほとんどの読み取りクエリがロックを取得しなくなる
        - 読み取りクエリはできるだけすばやくデータを読み取り、条件を満たしている行だけを確実に選択すればよい
        - ストレージエンジンが各行に記録するデータが増え、行を調べるときの作業が増え、細々した作業が増えるという欠点がある
        - MVCCは、REPEATABLE READ分離レベルとREAD COMMITTED分離レベルにのみ体操ている
        - READ UNCOMMITTEDがMVCC互換でないのは、クエリがそれらのトランザクションに適した行バージョンを読み取らないため
        - クエリは何があろうと最新バージョンを読み取る
        - SERIALIZEがMVCC互換でないのは、読み取りによりそれらが返す行がすべてロックされるため

## 1.5 MySQLのストレージエンジン

- スキーマ
    - 各データベースをそのデータディレクトリのサブディレクトリとしてファイルシステムに格納する
- テーブルと同じ名前の.frm拡張子が付いたファイルにテーブルの定義を保存する
    - 大文字と小文字の区別はプラットフォームに依存する
        - Windowsでは区別されない
        - UNIXでは区別される
    - テーブルのデータとインデックスの格納方法はストレージエンジンによって異なるが、テーブルを定義するのはサーバー自身
- テーブルに関する情報は`SHOW TABLE STATUS`コマンドまたは`INFORMATION SCHEMA`へ問い合わせる
    - Name：名前
    - Engine：テーブルのストレージエンジン
    - Row_format
        - 行のフォーマット
        - Dynamic：VARCHARやBLOBなどの可変長フィールド
        - Fixed：CHAR、INTEGERなどの常に同じサイズ
        - Compressed：圧縮されたテーブルのみに存在
    - Rows
        - テーブルの行数
        - MyISAM：正確
        - InnoDB：推定値
    - Avg_row_length：平均的な行に含まれるバイト数
    - Data_length：テーブル全体に含まれるデータの量
    - Max_data_length：格納できるデータに最大値
    - Index_length：インデックスデータが消費するディスク領域
    - Data_free
        - MyISAM：割り当てられているが使用されていない容量
            - すでに削除されていてINSERT分により回収できる量が含まれる
    - Auto_increment：次のAUTO_INCREMENT値
    - Create_time：テーブルが最初に作成された時間
    - Update_time：テーブル内のデータが最後に変更された時間
    - Check_time：CHECK TABLEまたはmyisamchkを使ってテーブルが最後にチェックされた時間
    - Collation：文字型の列に対するデフォルトの文字セットと照会順序
    - Checksum：テーブル全体の内容のリアルタイムチェックサム
    - Create_options：テーブルの作成時に指定されたその他のオプション
    - Comment：追加情報
        - MyISAM：テーブル作成時に追加されたコメント
        - InnoDB：テーブルの空き領域

### 1.5.3 InnoDBエンジン

- MySQLのデフォルトのトランザクショナルストレージエンジン
- ロールバックされずに完了する短命のトランザクション処理を前提
- パフォーマンスが良い
- 自動クラッシュリカバリ機能を備えている
- 基本はテーブルにはInnoDBを使用するべき
- ストレージエンジンについて調べたいならこれについてできるかぎり詳しくなるのが良い

**InnoDBの歴史**

- 2008年にMySQL用のInnoDBプラグインがリリース
- OracleがMySQLを買収してプラグインをデフォルトの置き換えてしまった
- 並び替えに基づいてインデックスを作成する機能
- テーブル全体を作り直さずにインデックスを削除したり追加する機能
- 圧縮をサポートする新しい格納様式
- BLOB列などに大きな値を格納する新しい方法
- ファイルフォーマットの管理
- MySQL5.1を使用するならばぜひプラグインを使用してほしい
- 多くのユーザーややベンダーが開発に投資して新機能が追加された
    - インストルメンテーション
    - スケーラビリティ
    - コンフィグレーション
    - パフォーマンス
    - 機能
    - Windowsサポート
- コア数が増えてもサポートされる

**InnoDBの概要**

- テーブル領域と総称される1つ以上のデータファイルにデータを保存する
    - 基本的にはブラックボックス
    - InnoDBにより完全管理
    - MySQL4.1以上のバージョンでInnoDBはテーブル単位でデータとインデックスを別のファイルの保存できる
    - テーブル領域を作成するためにローディスクパーティションを使用することもできる
- InnoDBはMVCCを使って高い並行性を実現し、SQLの標準の分離レベルを4つとも実装している
    - REPEATABLE READL分離レベルがデフォルト
    - ファントムリードを阻止するネクストキーロックアルゴリズムを適用
    - クエリでアクセスした行だけをロックするのではなく、インデックス構造の隙間もロックすることで挿入時にファントムが起きないようにしている
- InnoDBテーブルはクラスタ化インデックスに基づいて構築される
- セカンダリインデックスに主キー列が含まれるため、主キーが大きい場合は他のインデックスよりも大きくなる
- テーブルで使用するインデックスの数が大きい場合は、小さい主キーを使用することを心がけるようにする
- 格納形式はプラットフォームに依存しない
    - データファイルやインデックスファイルをIntelベースのサーバーからPowerPCやSun SPARCに問題なくコピーできる
- InnoDBの内部では最適化が走る
    - ディスクからデータを事前に取り出しておくための先読み
    - メモリ上でハッシュインデックスを自動的に作成する適応ハッシュインデックス
        - 高速なルックアップが可能になる
    - 挿入を高速化する挿入バッファ
- InnoDBを使用する場合にはMySQLマニュアルを参照する
- InnoDBはMVCCアーキテクチャに基づいている
- オンラインバックアップをサポートしている

### 1.5.2 MyISAMエンジン

- トランザクションまたは行レベルのロックをサポートしていない
- クラッシュセーフではない
- 読み取り専用のデータが必要な場合、あるいはテーブルがそれほど大きくないので修復が苦にならない場合は検討してもよい

**ストレージ**

- 各テーブルをデータファイルとインデックスファイルの2つのファイルに保存する
- .MYDと.MYIという拡張子
    - 動的な行または静的な行のどちらかを含めることができる
- テーブルの定義に基づいて使用する格納形式を決定する
- MyISAMテーブルに収容できる行の数はデータベース・サーバー上のディスクの空き領域とオペレーティングシステムで作成可能なファイルの最大サイズによって制限される

**MyISAMの機能**

ロックと並行性

- MyISAMは行ではなくテーブル全体をロックする
- リーダーは読み取る必要がある全てのテーブルで共有ロックを取得し、ライターは排他ロックを取得する
- 選択クエリが実行されているテーブルに新しい行を挿入することが可能である

リペア

- MySQLはMyISAMテーブルのチェックとリペアを手動及び自動でサポートしている
    - トランザクションやクラッシュリカバリと混同しないように注意すること
        - テーブルをリペアしたあと、一部のデータが完全に消えていることがある
- 確認方法
    - CHECK TABLEコマンド
    - REPAIR TABLEコマンド
    - myisamchkコマンドラインツール（オフライン時）

インデックス機能

- MyISAMテーブルのBLOB列とTEXT列の最初の500文字でインデックスを作成できる
- MyISAMは複雑な検索操作のために個々の単語にインデックスを付ける全文インデックスをサポート

遅延キー書き込み

- DELAY_KEY_WRITEオプションを指定すると、そのテーブルは変更されたインデックスデータをクエリの最後にディスクに書き込まなくなり、代わりに変更されたデータをメモリ内のキーバッファに書き込むようになる
- インデックスデータはバッファを入れ替えるかテーブルを閉じるときに、ディスクにフラッシュされる
- パフォーマンスがよくなることがあるが、サーバーやシステムがクラッシュすればインデックスは確実に破壊されるためリペアが必要になる

**圧縮されたMyISAMテーブル**

- 作成されてデータが挿入されて変化しないテーブルは圧縮されたMyISAMテーブルにうってうけ
- myisampackユーティリティを使って圧縮
- 圧縮されたテーブルは変更できなくが、必要であれば圧縮を解除して変更を加えたあと、再び圧縮することができる
- テーブルのサイズが小さいほどレコードを検索するのに必要なディスクシークが少なくなるので結果としてパフォーマンスがよくなる
- インデックスを作成することは可能だが、それは読み取り専用
- 圧縮解除のオーバーヘッドよりもディスクI/Oを減らすことのほうが本当の価値がある
- 行は個別に圧縮されるため、行を1つ取り出すためにMySQLがテーブルあるいはページ全体をアンパックする必要はない

**MyISAMのパフォーマンス**

- データストレージがコンパクトで、設計がシンプルでオーバーヘッドが少ないMyISAMは、用途によって優れたパフォーマンスを達成できる
- キーキャッシュのミューテックスを含め、スケーラビリティに深刻な制限がある
    - この問題を避けるため、MariaDBではセグメント化されたキーキャッシュを提供している
- MyISAMのパフォーマンス問題はテーブルのロック
- クエリがすべて「ロック」状態に陥った場合は、テーブルレベルのロックに悩まされることになる

### 1.5.3 MySQLのその他の組み込みエンジン

- 新しいバージョンではあまり使用されなくなっている

**Archiveエンジン**

- INSERTクエリとSELECTクエリのみをサポート
- MySQL5.1まではインデックスをサポートしていない
- データ書き込みをバッファに溜め込み、各行を挿入するときにzlibで圧縮するため、ディスクI/Oがかなり少ない
- SELECTクエリではテーブル全体のスキャンが必要になる
- Archiveテーブルに最適なのは、解析時にテーブル全体をスキャンする傾向にあるか、高速なINSERTクエリが必要となる、ログの記録やデータの取得
- 並行性の高い挿入を可能にするために、行レベルのロックと特殊なバッファシステムをサポート
- クエリを開始したときにテーブルに存在していただけの行を取得したところでSELECTを狩猟することで読み寄りの一貫性を確保する
- 一括挿入では完了するところまで挿入行を不可視にする

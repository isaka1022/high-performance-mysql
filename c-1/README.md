# 1章 MySQLのアーキテクチャと歴史

- MySQLは他のデータベースサーバーとは違う
- アーキテクチャに特徴がある
- 柔軟
- MySQLの最も独特で重要な機能は、クエリ処理やその他のサーバータスクをデータの格納と取得から分離するように設計されたストレージエンジンアーキテクチャ

## 1.1 MySQLの論理アーキテクチャ

- 一番上のレイヤには接続処理/認証/セキュリティなどネットワークベースの殆どのクライアント/サーバーツールで必要となるサービス
- 2つめにはクリエ解析、分析、最適化、キャッシュ、組み込み関数、ストアドプロシージャ、トリガ、ビュー
- 3つめにはストレージエンジンが含まれる
    - MySQLの中に格納されているすべてのデータの保存と取得を受け持つ
    - サーバーはストレージエンジンAPIを通じてそれらとやりとりする
    - クエリレイヤでは見分けがつかなくなる

### 1.1.1 接続の管理とセキュリティ

- クライアント接続はそれぞれサーバープロセス内で独自のスレッドを取得する
- 接続のクエはその1つのスレッドで実行され、1つのコアまたはCPUと関連付けられる
- サーバーはスレッドをキャッシュする
    - 新しい接続のたびにスレッドの作成と削除を繰り返す必要はない
- クライアントがMySQLサーバーに接続するためにはサーバーが認証する必要がある
    - ユーザー名
    - 接続先ホスト
    - パスワード
    - SSL接続でX.509証明書を使用することもできる
    - クライアントが接続後に、サーバーはクライアントがworldデーターベースのCountryテーブルにSELECT文を送信する権限を持っているかどうかなど、クライアントがクエリに関する特権を持っているかどうかを確認する

### 1.1.2 最適化と実行

- MySQLはクエリを解析して内部構造を作成した後に、最適化を使用する
    - クエリの書き換え、テーブルを読み取る順序の決定、使用するインデックスの選択など
- クエリの特殊なキーワードを通じてオプティマイザにヒントを私、意思決定プロセスを反映させることもできる
- クエリ、スキーマ、設計を見直してすべてをできるだけ効率化するための基準点が得られる
- オプティマイザはどのテーブルがどのストレージエンジン使用するかについてはあまり関しがないが、ストレージエンジンはサーバーがクエリを最適化する方法に影響を与える
- オプティマイザはストレージエンジンの機能、特定の操作にかかるコスト、テーブルデータの統計をストレージエンジンに問い合わせる
- サーバーはクエリを解析する前であっても、SELECT文とそれらの結果セットだけが格納されるクエリキャッシュを調べる
- 送信されたクエリがすでにキャッシュに含まれるものと同じだった場合、キャッシュに格納されている結果セットを返すだけでよい

## 1.2 並行性の制御

- 複数のクエリがデータを同時に変更する必要が生じるたびに、並行性の制御が問題
- MySQLはサーバーレベルとストレージエンジンレベルの2つのレベルでそれを制御する必要がある

### 1.2.1 読み取り/書き込みロック

- 同時読み取り/書き込みアクセスに対処するシステムは2つの種類のロックシステムを実装する
    - 共有ロックと排他ロック、または読み取りロックと書き込みロック
- リソースの読み取りロックは共有されるまたは相互にノンブロッキング
    - 複数のクライアントがリソースを同時に読み取り、互いに干渉しない
- 書き込みロックは排他的
    - 読み取りロックと他の書き込みロックの両方をブロックする
- 常にリソースへの書き込みを行うクライアントを1つだけにし、書き込み中は読み取りを阻止するのが安全なポリシーだから

### 1.2.2 ロックの粒度

- 共有リソースの並行性を向上させる方法は、何をロックするかについて細かく選択する
    - 変更する必要があるデータが含まれている部分だけロック
    - 変更する予定のデータだけをロック
- ロックがリソースを消費する
    - ロックの取得
    - ロックが空いているかどうかのチェック
    - ロックの解除
- ロック戦略：ロックのオーバーヘッドとデータの安全性に折り合いをつけること
- ほとんどはテーブルでの行ロック
- MySQLは独自のロックポリシーとロック粒度を実装できる

**テーブルロック**

- 最も基本的で最もオーバーヘッドが低い
- テーブルに対して挿入、削除、更新などの書き込み操作を行いたいクライアントは書き込みロックを取得する
- 他の読み取り/書き込み操作はすべて拒否される
- 特定の状況でパフォーマンスを高めるバリエーション
    - READ LOCALテーブルロックは一種の同時書き込み操作を許可する
    - 書き込みロックは読み取りロックよりもキューの前方に配置される

**行ロック**

- 並行性、オーバーヘッドが最も高いロック方式
- InnoDBやXtraDBでも利用できる
- サーバーでなくてストレージエンジンで実装される
- サーバーはストレージエンジンで実装されるロックのことを何も知らない

## 1.2 トランザクション

- 1つの作業単位としてアトミックに扱われるSQLクエリの集まり
    - クエリ全体をデータベースに適用できる場合にはそうするが、クラッシュなどの理由で実行できないクエリがあればどのクエリも適用しない
- ACID
- アトミック姓
    - トランザクション全体が1つの分割できない作業単位として機能する
    - すべて完了するか、全て完了しないか
- 一貫性
    - 一つの一貫した状態から次の一貫した状態へ遷移すべき
- 分離性
    - トランザクションの結果はすべて完了するまで他のトランザクションからは見れない
- 永続性
    - コミットされたトランザクションの変更は確定される
    - 変更は記録される
- ACIDトランザクションに対応するデータベースサーバーはCPUパワー、メモリ、ディスク領域を必要とする
- 特定の種類のクエリにトランザクションに対応しないストレージエンジンを使用することでパフォーマンスを改善できるかもしれない

### 1.3.1 分離レベル

- SQL規格は4つの分離レベルを定義
- 分離レベルが低いほど並行性が高くなりオーバーヘッドが低くなる

**READ UNCOMMITTED**

- コミットされていないトランザクションの結果が他のトランザクションから見える
- いろいろな問題をはらんでいる
- 滅多に使われない
- ダーティリードとも呼ばれる

**READ COMMITED**

- ほとんどのRDBSのデフォルトの分離レベル
- トランザクションから見えるのはそれが開始された時にコミットされていたトランザクションによる変更だけ
- ノンリピータブルリードが許可
    - 同じステートメントを2回実行すると異なるデータが返される可能性がある

**REPEATABLE READ**

- トランザクションが読み取るすべての行が同じトランザクションのそれ以降の読み取りで同じに見えることが保証
- ファントムリードのも谷がある
    - ある範囲の行を選択した後、別のトランザクションがその範囲に新しい行を挿入し、その後に同じ範囲を再び選択したときに、新しい幻のファントムが現れる
- InnoDBとXtraDBはMVCCに基づいてファントムリードの問題を解決する
- MySQLのデフォルトのトランザクション分離レベルSERIALIZABLE

**SERIALIZABLE**

- 最も高いレベルの分離性
- 競合が怒らないようにトランザクションを強制的に順序付けて解決
- すべての読みとる行にロックを設定

### 1.3.2 デッドロック

- 複数のトランザクションが同じリソースのロックをめぐって競合し、それぞれのロックをリクエストして依存関係の循環を招くこと
- トランザクションが異なる順序でリソースをロックしようとしたとき
- InnoDBストレージエンジンなどの高度なシステムは循環依存を検知するとすぐにエラーを返す
- ロック待ちのタイムアウトが過ぎた時点でクエリの処理を断念しても、必ずしもよいとは限らない
- InnoDBは現在の排他ロックの数が最も少ないトランザクションをロールバックすることでデッドロックに対処している
- トランザクションを部分的または完全にロールバックしなければデッドロックは解除できない

### 1.3.3 トランザクションログ

- ストレージエンジンは変更が発生するたびにディスク上のテーブルを更新するのではなく、データのメモリ上のコピーを変更するだけでよい
- その後、ストレージエンジンの変更の記録をトランザクションログに書き込むことができる
    - ディスク上にあるため永続化できる
- ディスク上をあちこち飛び回るランダムI/Oではなく狭い範囲のシーケンシャルなI/Oが使用されるので、ログイベントの追加も比較的高速
- ログの先行書き込み
- トランザクションログに書き込まれたからデータ自体が変更されるまでの間にクラッシュしても、ストレージエンジンは再起動時に変更を取り戻すことができる

### 1.3.4 MySQLのトランザクション

- MySQLはInnoDBとNDB Clusterのトランザクショナルストレージエンジンを提供している

**AUTOCOMMIT**

- MySQLはデフォルトではAUTOCOMMIT
- クエリはそれぞれ別々のトランザクションで実行される
- AUTOCOMMITの値を変更しても、MyISAMやMemoryデーブルといった非トランザクショナルテーブルへの変更はない
- 実行中のトランザクションで発行するとMySQLがそのコマンドを実行する前にそのトランザクションをコミットするものがある
    - ALTER TABLEのような大幅な変更を行うDDL(Data Definition Language)コマンド
    - LOCK TABLE
- MySQLで分離レベルを設定するには`SET TRANSACTION ISOLATION LEVEL` コマンドを使用する

**トランザクションでの複数のストレージエンジンの併用**

- MySQLはトランザクションをサーバーレベルで管理しない
    - ストレージエンジンが管理
    - 複数のエンジンを1つのトランザクションで併用することが不可能
- トランザクショナルテーブルと非トランザクショナルテーブルがトランザクションに含まれている場合順当にいけばトランザクションは正常に処理される
- ロールバックが要求された場合、非トランザクショナルテーブルへの変更を取り消すことはできない
- MySQLは非トランザクショナルテーブルでトランザクション操作を行ったとしても通常は警告やエラーを生成しない

**暗黙的なロックと明示的なロック**

- InnoDBは2相のロックプロトコルを使用する
- トランザクションの実行中はいつでも使用できるが、`COMMIT`または`ROLLBACK`まで開放されない
- InnoDBはすべてのロックを同時に開放する
    - すべて暗黙的
    - 分離レベルに基づいてロックを自動的に処理する
- InnoDBは明示的なロックもサポート
    - SELECT ... LOCK IN SHARE MODE
    - SELECT ... FOR UPDATE
- ストレージエンジンではなくサーバー上で実装される
- MyISAMからInnoDBに変換されているものの依然としてLOCK TABLESを使用しているアプリケーションをよく見かける
    - 行レベルのロックなのでもはや不要で、パフォーマンスを劇的に低下させる可能性がある

## 1.4 マルチバージョンの並行性制御

- MySQLのトランザクショナルストレージエンジンの行レベルのロックとMVCCと呼ばれる並行性を高める手法を組み合わせて使用する
- MVCCでロックの必要性を完全に排除し、オーバーヘッドの多くを解消する可能性がある
    - ロックを使用しない読み取りを許可する一方で、書き込み操作では必要なレコードだけをロックする
- MVCCはある時点で存在していたデータのスナップショットを作成するという仕組みで動作する
    - トランザクションの長さに関わらず、参照できるデータは一貫
    - 複数のトランザクションが同じテーブル内にあの異なるデータを同時に参照することも意味する
- 楽観的（オプティミスティック）並行性制御と悲観的（ペシミスティック）並行性制御
- InnoDBによるMVCCの実装
    - 行ごとに隠れた値を2つ格納する
        - 行が生成されたタイミング
        - 行が期限切れになった（削除された）タイミング
    - 各イベントが発生された時刻ではなくシステムバージョンを記録
    - トランザクションは開始時点でのシステムバージョンを記録
    - SELECT
        - InnoDBは各行を調べて以下の2つの条件が満たされていることを確認
            - 少なくともトランザクションと同じかそれ以前のバージョンの行を検索しなければならない
            - 行の削除バージョンは未定義であるか、トランザクションのバージョンよりも新しいバージョンでなければならない
    - INSERT
        - 現在のシステムバージョンを新しい行に記録する
    - UPDATE
        - InnoDBは新しいバージョンに対応するシステムバージョン番号を使って新しいコピーを書き出す
        - 古い行の削除バージョンとしてシステムバージョン番号を書き出す
    - これらの追加レコードを記録すると、ほとんどの読み取りクエリがロックを取得しなくなる
        - 読み取りクエリはできるだけすばやくデータを読み取り、条件を満たしている行だけを確実に選択すればよい
        - ストレージエンジンが各行に記録するデータが増え、行を調べるときの作業が増え、細々した作業が増えるという欠点がある
        - MVCCは、REPEATABLE READ分離レベルとREAD COMMITTED分離レベルにのみ体操ている
        - READ UNCOMMITTEDがMVCC互換でないのは、クエリがそれらのトランザクションに適した行バージョンを読み取らないため
        - クエリは何があろうと最新バージョンを読み取る
        - SERIALIZEがMVCC互換でないのは、読み取りによりそれらが返す行がすべてロックされるため

## 1.5 MySQLのストレージエンジン

- スキーマ
    - 各データベースをそのデータディレクトリのサブディレクトリとしてファイルシステムに格納する
- テーブルと同じ名前の.frm拡張子が付いたファイルにテーブルの定義を保存する
    - 大文字と小文字の区別はプラットフォームに依存する
        - Windowsでは区別されない
        - UNIXでは区別される
    - テーブルのデータとインデックスの格納方法はストレージエンジンによって異なるが、テーブルを定義するのはサーバー自身
- テーブルに関する情報は`SHOW TABLE STATUS`コマンドまたは`INFORMATION SCHEMA`へ問い合わせる
    - Name：名前
    - Engine：テーブルのストレージエンジン
    - Row_format
        - 行のフォーマット
        - Dynamic：VARCHARやBLOBなどの可変長フィールド
        - Fixed：CHAR、INTEGERなどの常に同じサイズ
        - Compressed：圧縮されたテーブルのみに存在
    - Rows
        - テーブルの行数
        - MyISAM：正確
        - InnoDB：推定値
    - Avg_row_length：平均的な行に含まれるバイト数
    - Data_length：テーブル全体に含まれるデータの量
    - Max_data_length：格納できるデータに最大値
    - Index_length：インデックスデータが消費するディスク領域
    - Data_free
        - MyISAM：割り当てられているが使用されていない容量
            - すでに削除されていてINSERT分により回収できる量が含まれる
    - Auto_increment：次のAUTO_INCREMENT値
    - Create_time：テーブルが最初に作成された時間
    - Update_time：テーブル内のデータが最後に変更された時間
    - Check_time：CHECK TABLEまたはmyisamchkを使ってテーブルが最後にチェックされた時間
    - Collation：文字型の列に対するデフォルトの文字セットと照会順序
    - Checksum：テーブル全体の内容のリアルタイムチェックサム
    - Create_options：テーブルの作成時に指定されたその他のオプション
    - Comment：追加情報
        - MyISAM：テーブル作成時に追加されたコメント
        - InnoDB：テーブルの空き領域

### 1.5.3 InnoDBエンジン

- MySQLのデフォルトのトランザクショナルストレージエンジン
- ロールバックされずに完了する短命のトランザクション処理を前提
- パフォーマンスが良い
- 自動クラッシュリカバリ機能を備えている
- 基本はテーブルにはInnoDBを使用するべき
- ストレージエンジンについて調べたいならこれについてできるかぎり詳しくなるのが良い

**InnoDBの歴史**

- 2008年にMySQL用のInnoDBプラグインがリリース
- OracleがMySQLを買収してプラグインをデフォルトの置き換えてしまった
- 並び替えに基づいてインデックスを作成する機能
- テーブル全体を作り直さずにインデックスを削除したり追加する機能
- 圧縮をサポートする新しい格納様式
- BLOB列などに大きな値を格納する新しい方法
- ファイルフォーマットの管理
- MySQL5.1を使用するならばぜひプラグインを使用してほしい
- 多くのユーザーややベンダーが開発に投資して新機能が追加された
    - インストルメンテーション
    - スケーラビリティ
    - コンフィグレーション
    - パフォーマンス
    - 機能
    - Windowsサポート
- コア数が増えてもサポートされる

**InnoDBの概要**

- テーブル領域と総称される1つ以上のデータファイルにデータを保存する
    - 基本的にはブラックボックス
    - InnoDBにより完全管理
    - MySQL4.1以上のバージョンでInnoDBはテーブル単位でデータとインデックスを別のファイルの保存できる
    - テーブル領域を作成するためにローディスクパーティションを使用することもできる
- InnoDBはMVCCを使って高い並行性を実現し、SQLの標準の分離レベルを4つとも実装している
    - REPEATABLE READL分離レベルがデフォルト
    - ファントムリードを阻止するネクストキーロックアルゴリズムを適用
    - クエリでアクセスした行だけをロックするのではなく、インデックス構造の隙間もロックすることで挿入時にファントムが起きないようにしている
- InnoDBテーブルはクラスタ化インデックスに基づいて構築される
- セカンダリインデックスに主キー列が含まれるため、主キーが大きい場合は他のインデックスよりも大きくなる
- テーブルで使用するインデックスの数が大きい場合は、小さい主キーを使用することを心がけるようにする
- 格納形式はプラットフォームに依存しない
    - データファイルやインデックスファイルをIntelベースのサーバーからPowerPCやSun SPARCに問題なくコピーできる
- InnoDBの内部では最適化が走る
    - ディスクからデータを事前に取り出しておくための先読み
    - メモリ上でハッシュインデックスを自動的に作成する適応ハッシュインデックス
        - 高速なルックアップが可能になる
    - 挿入を高速化する挿入バッファ
- InnoDBを使用する場合にはMySQLマニュアルを参照する
- InnoDBはMVCCアーキテクチャに基づいている
- オンラインバックアップをサポートしている

### 1.5.2 MyISAMエンジン

- トランザクションまたは行レベルのロックをサポートしていない
- クラッシュセーフではない
- 読み取り専用のデータが必要な場合、あるいはテーブルがそれほど大きくないので修復が苦にならない場合は検討してもよい

**ストレージ**

- 各テーブルをデータファイルとインデックスファイルの2つのファイルに保存する
- .MYDと.MYIという拡張子
    - 動的な行または静的な行のどちらかを含めることができる
- テーブルの定義に基づいて使用する格納形式を決定する
- MyISAMテーブルに収容できる行の数はデータベース・サーバー上のディスクの空き領域とオペレーティングシステムで作成可能なファイルの最大サイズによって制限される

**MyISAMの機能**

ロックと並行性

- MyISAMは行ではなくテーブル全体をロックする
- リーダーは読み取る必要がある全てのテーブルで共有ロックを取得し、ライターは排他ロックを取得する
- 選択クエリが実行されているテーブルに新しい行を挿入することが可能である

リペア

- MySQLはMyISAMテーブルのチェックとリペアを手動及び自動でサポートしている
    - トランザクションやクラッシュリカバリと混同しないように注意すること
        - テーブルをリペアしたあと、一部のデータが完全に消えていることがある
- 確認方法
    - CHECK TABLEコマンド
    - REPAIR TABLEコマンド
    - myisamchkコマンドラインツール（オフライン時）

インデックス機能

- MyISAMテーブルのBLOB列とTEXT列の最初の500文字でインデックスを作成できる
- MyISAMは複雑な検索操作のために個々の単語にインデックスを付ける全文インデックスをサポート

遅延キー書き込み

- DELAY_KEY_WRITEオプションを指定すると、そのテーブルは変更されたインデックスデータをクエリの最後にディスクに書き込まなくなり、代わりに変更されたデータをメモリ内のキーバッファに書き込むようになる
- インデックスデータはバッファを入れ替えるかテーブルを閉じるときに、ディスクにフラッシュされる
- パフォーマンスがよくなることがあるが、サーバーやシステムがクラッシュすればインデックスは確実に破壊されるためリペアが必要になる

**圧縮されたMyISAMテーブル**

- 作成されてデータが挿入されて変化しないテーブルは圧縮されたMyISAMテーブルにうってうけ
- myisampackユーティリティを使って圧縮
- 圧縮されたテーブルは変更できなくが、必要であれば圧縮を解除して変更を加えたあと、再び圧縮することができる
- テーブルのサイズが小さいほどレコードを検索するのに必要なディスクシークが少なくなるので結果としてパフォーマンスがよくなる
- インデックスを作成することは可能だが、それは読み取り専用
- 圧縮解除のオーバーヘッドよりもディスクI/Oを減らすことのほうが本当の価値がある
- 行は個別に圧縮されるため、行を1つ取り出すためにMySQLがテーブルあるいはページ全体をアンパックする必要はない

**MyISAMのパフォーマンス**

- データストレージがコンパクトで、設計がシンプルでオーバーヘッドが少ないMyISAMは、用途によって優れたパフォーマンスを達成できる
- キーキャッシュのミューテックスを含め、スケーラビリティに深刻な制限がある
    - この問題を避けるため、MariaDBではセグメント化されたキーキャッシュを提供している
- MyISAMのパフォーマンス問題はテーブルのロック
- クエリがすべて「ロック」状態に陥った場合は、テーブルレベルのロックに悩まされることになる

### 1.5.3 MySQLのその他の組み込みエンジン

- 新しいバージョンではあまり使用されなくなっている

**Archiveエンジン**

- INSERTクエリとSELECTクエリのみをサポート
- MySQL5.1まではインデックスをサポートしていない
- データ書き込みをバッファに溜め込み、各行を挿入するときにzlibで圧縮するため、ディスクI/Oがかなり少ない
- SELECTクエリではテーブル全体のスキャンが必要になる
- Archiveテーブルに最適なのは、解析時にテーブル全体をスキャンする傾向にあるか、高速なINSERTクエリが必要となる、ログの記録やデータの取得
- 並行性の高い挿入を可能にするために、行レベルのロックと特殊なバッファシステムをサポート
- クエリを開始したときにテーブルに存在していただけの行を取得したところでSELECTを狩猟することで読み寄りの一貫性を確保する
- 一括挿入では完了するところまで挿入行を不可視にする

### 1.5.3 MySQLのその他の組み込みエンジン

- 新しいバージョンではあまり使用されなくなっている

**Archiveエンジン**

- INSERTクエリとSELECTクエリのみをサポート
- MySQL5.1まではインデックスをサポートしていない
- データ書き込みをバッファに溜め込み、各行を挿入するときにzlibで圧縮するため、ディスクI/Oがかなり少ない
- SELECTクエリではテーブル全体のスキャンが必要になる
- Archiveテーブルに最適なのは、解析時にテーブル全体をスキャンする傾向にあるか、高速なINSERTクエリが必要となる、ログの記録やデータの取得
- 並行性の高い挿入を可能にするために、行レベルのロックと特殊なバッファシステムをサポート
- クエリを開始したときにテーブルに存在していただけの行を取得したところでSELECTを狩猟することで読み寄りの一貫性を確保する
- 一括挿入では完了するところまで挿入行を不可視にする

**Blackholeエンジン**

- ストレージメカニズムが全くない
- INSERTを格納せずに捨ててしまう
- クエリはサーバーのログに記録されるので
    - レプリカにレプリケートする
    - そのままログに保存する
- エンジンは複雑なレプリケーション構成や監査ログによく使用されている
- セットアップに起因する問題

**CSVエンジン**

- CSVファイルをテーブルとして扱う
- インデックスはサポートしない
- サーバーの実行中にデータベースとの間でファイルのコピーを行う
- CSVファイルをスプレッドシートからエクスポートして、MySQLサーバ位のデータディレクトリに保存する
- データをCSVファイルに書き込めば、外部プログラムがそれをすぐに読み取れるようになる
- データ交換フォーマットとして喜ぶ

**Federatedエンジン**

- 他サーバーへのプロキシ
- 別サーバーへのクライアント接続を開いて、そのサーバーに保存されているテーブルに対してクエリを実行し、必要に応じて行を取得または送信する
- 多くの問題の原因となることが判明したため、デフォルトで無効になっている

**Memoryエンジン**

- 決して変化しないデータや再起動後に残っている必要がないデータへの高速アクセスが必要な場合に役立つ
- MemoryテーブルはMyISAMテーブルよりも10倍ほど高速である
- Memoryテーブルのデータはすべてメモリ上に格納されているのでクエリはディスクI/Oを保つ必要がない
- Memoryテーブルのテーブル構造はサーバーを再起動したあとも維持されるが、データは失われる
- Memoryテーブルの用途
    - 郵便番号を市区町村名にマッピングするテーブルなど、ルックアップテーブルやマッピングテーブル
    - 定期的に集計されるデータや結果をキャッシュするために
    - データを分析するときの中間結果
- 高速なハッシュインデックスをサポート
- ディスクベースのテーブルに代わる汎用テーブルとしてはうまくいかない
- テーブルレベルのロックを使用しており、書き込みの並行性を低下させている
- TEXT型またはBLOB型の列をサポートしない
- 固定長の行だけをサポートするので、実際にはVARCHARをCHARとして格納し、メモリを無駄にする可能性がある
- 実行しているクエリの中間結果を保持するために一時テーブルが必要な場合、MySQLは内部でMemoryエンジンを使用する
    - 中間結果が大きくなりすぎてMemoryテーブルの限界を超えるか、TEXT列またｈBLOB列が存在する場合、MySQLはそれをディスク上のMyISAMテーブルに変換する

**Mergeエンジン**

- MyISAMの一種
- 複数の同一のMyISAMテーブルを一つの仮想テーブルとして組み合わせたもの
- MySQLをログ機能やデータウェアハウジングアプリケーションで使用するときに役立つ可能性があるが、パーティショニングのほうが主流になっている

**NDB Clusterエンジン**

- 2003年にSony EricssonからNDB Clusterエンジンを取得

### 1.5.4 サードパーティのストレージエンジン

- MySQLからの

〜〜一旦スキップ〜〜

### 1.5.5 正しいストレージエンジンの選択

- 通常はInnoDBを選択すれば問題ない
- InnoDBにない機能が必要であり、かつ、InnoDBにはよい代替案がないという場合でない限り、InnoDBを使用する
    - 全文検索が必要であるとき、MyISAMの全文インデックス機能を選択するよりも、InnoDBとSphinxを組みあわせて使用するほうがよい
- InnoDBの機能が必要でなく、別のエンジンに抗しがたいメリットがあり、欠点が見当たらない場合ほかを選択
    - スケーラビリティが制限されていて、並行性のサポートが十分でなく、クラッシュへの耐性がなくてもかまわず、逆にInnoDBを使用したときの消費スペースの増加が問題となる場合はMyISAMを使用するかも
- どうしても必要な場合を除いて、異なるストレージエンジンを組み合わせて使用するのは避けたい
    - 状況がかなり複雑になる
    - まったく新しいバグや極端なケースでの振る舞いに直面することになる
- 別のストレージエンジンがどうしても必要になると考える場合に検討すべき要因
    - トランザクション
        - 最も適しているのはInnoDB
        - MyISAMが適しているのはトランザクションを必要とせずSELECTかINSERTクエリを実行するタスク
            - ログ機能など
    - バックアップ
        - バックアップを定期的に実行する必要があるかどうかがテーブルの選択を左右することもある
        - バックアップのためにサーバーを定期的にシャットダウンできる場合は、どのストレージエンジンも簡単に対応できる
        - オンラインバックアップを実行する場合があるとしたら、基本的にInnoDBが必要
    - クラッシュリカバリ
        - データ量が多い場合は、クラッシュからのリカバリにかかる時間の長さについて真剣に検討すべき
        - MyISAMテーブルはクラッシュしやすい
            - InnoDBテーブルよりもリカバリにかかる時間がずっと長い
    - 特殊な機能
        - クラスタ化インデックスの最適化
        - MySQLの空間検索をサポートしているのはMyISAMだけ
- たくさんの選択肢があるが、よくわからない場合はInnoDBを使用すること

**ログ**

- 最も重要な目標はスピード
- MyISAMとArchiveストレージエンジンはオーバーヘッドがきわめて低く1秒間に数千件ものレコードを挿入できる
- ログで記録したデータをレポートにまとめる必要がある場合、クエリによってレポート用のデータの収集プロセスによって、レコードを挿入するプロセスのパフォーマンスを著しく低下させる
- MySQLのレプリケーション機能を使ってデータをコピーしたあとにCPUに負荷をかけるクエリをレプリカのデータで実行する
    - マスターではレコードを挿入し、レプリカでは必要なクエリを自由に実行可能
- 負荷の少ない時間帯にクエリを実行する
    - アプリケーションが大きくなるに従ってうまくいかない可能性がある
- 名前に都年と月の番号が含まれているテーブルにログを記録する
    - 書き込みから開放されたテーブルでクエリが実行されている間、アプリケーションは邪魔されずに現在のテーブルにレコードを記録できる

**読み取り専用または読み取り主体のテーブル**

- 書き込みよりも読み取りの方がはるかに多い
    - 求人、オークション、不動産などのカタログやリストなど
- MyISAMの良い候補
    - クラッシュしたときに何が起きても気にしなのであれば
- データをディスクに書き込む努力すらしないストレージエンジンを使用するのは危険
- MyISAMはデータをメモリに書き込むだけで、OSがあとからディスクにフラッシュする
- 「MyISAMはInnoDBより高速」を鵜呑みにしない、真実ではない
    - クラスタ化インデックスが役立つアプリケーションやデータがメモリ内に収めるのであればとくに

**注文処理**

- 確実にトランザクションが必要となる
- InnoDBを使用するのが最も確実な方法

**掲示板とスレッド形式のディスカッションフォーラム**

- いくつかの巨大テーブルにすべてを格納する
- 一握りの中央テーブルに読み取りと書き込みが集中し、整合性を確保するための必要なロックがあろうことか競合をまねく

**CD-ROMアプリケーション**

- MyISAMテーブルか圧縮されたMyISAMテーブルを使用することを検討しよう

**大容量データ**

- InnoDBデータベーシスをいくつも作成し、管理できるがハードウェアの選択や物理的設計を誤ってはならない
- MyISAMを使用するとクラッシュした場合は最悪
- サイズが数十テラバイトといった規模になる場合はデータウェアハウスを構築する
    - Infobrightが最もうまくいく
    - データサイズが多く過ぎてうまくイカない場合はTokuDBがよい

### 1.5.6 テーブルの変換

**ALTER TABLE**

- テーブルを別のストレージエンジンに移動する最も簡単な方法

```ruby
mysql > ALTER TABLE mytable ENGINE = InnoDB;
```

- かなり時間がかかるかもしれない
- MySQLは古いテーブルから新しいテーブルへ行単位でコピーを行う
- 変換中はサーバディスクI/Oキャパシティがすべて使用され、変換元のテーブルに読みよりロックが適用される
- アクセス数が多いテーブルで試す場合は注意が必要
- ストレージエンジンからストレージエンジンへの変換の際には、ストレージエンジン固有の機能はすべて無効になる
    - InnoDBからMyISAMへの変換のあと、再びInnoDBに変換する場合、最初に定義されていた外部キーはすべて消える

**ダンプとインポート**

- mysqldumpユーティリティで最初にテーブルをテキストファイルにダンプする
- ダンプファイルを編集して、テーブルに含まれているCREATE TABLEを調整できる
- テーブルの種類と名前を必ず変更すること
    - 同じデータベース内に同じ名前を持つテーブルを2つ作成することはできない
- mysqldumpはデフォルトでCREATE TABLEコマンドの前にDROP TABLEコマンドを書き出すため、注意していないとデータを失う

## 2.3 ベンチマークの戦術

- 一般的な間違い
    - 実施のデータサイズの一部しか使用していない
        - 数百ギガバイトのデータを処理しなければならないアプリケーションでたった1ギガバイトのデータしか使用しない、あるいは大幅な成長が見込まれているアプリケーションで現在のデータセットを使用するなど
    - 不正確に分散されたデータを使用している
    - 非現実的に分散されたパラメータを使用している
    - マルチユーザーアプリケーションに対してシングルユーザーのシナリオを使用している
    - 1台のサーバー上で分散アプリケーションのベンチマークを使用している
    - Webページの思考時間などが現実のユーザーの振る舞いを一致していない
    →現実のユーザーは、ページをリクエストしてそれを読むため、間髪入れずにリンクをクリックしない
    - ループを使って全く同じクエリを実行する
    →現実のクエリは全く同じではないため、キャッシュミスを引き起こす
    - エラーのチェックを怠っている
    →ベンチマークの結果が意味をなさないときはエラーをチェックする
        - ベンチマークの後は必ずエラーログをチェックすること
    - リブートの直後であるなど、システムのウォームアップが完了していないときのパフォーマンスを無視している
    →ウォームアップ時間は具体的に調べたほうがよい
        - リブート直後のベンチマークでは多くのキャッシュがコールドとなり、キャッシュがウォームアップしているときの負荷で得られるはずの結果がベンチマークに反映されない
    - デフォルトのサーバー設定を使用している
    →サーバーは最適化させる必要がある
    - ベンチマークの時間が短すぎる
    →ベンチマークはしばらく実行し続ける必要がある
- これらの誤りを避けるだけで結果の品質の向上に大きく役立つ
- 通常はテストができるだけ現実的なものになるように努力すべき
- 少し非現実的なベンチマークを使用するとよいこと
    - アプリケーションがデータベースサーバーと別のホストで実行される
        - 同じ構成でベンチマークを実行するほうが現実だが、ネットワーク速度や負荷といった変数が追加される
        - 1つのノードでベンチマークするほうが通常は楽で、十分な場合も

### 2.3.1 ベンチマークの設計と計画

- 問題と目標を洗い出す
- 標準のベンチマークを使用するのか、独自に設定するのか決定する
    - 標準のベンチマークを使用する場合、ニーズに適合するものを選択する
    - カスタムベンチマークの設計は、複雑で繰り返しの多いプロセス
        - 実際の稼働環境のデータセットのスナップショットを作成する
- データに対して実行するクエリを用意する
    - ユニットテストスイートを何度か実行するだけで基本的なベンチマークは作成できる
    - それがデータベースの現実的な使用法と一致する可能性は低い
    - ピーク時やまる一日といった代表的な時間枠で、実際の稼働環境のシステム上で実行されるクエリをすべて記録するほうがよい
    -

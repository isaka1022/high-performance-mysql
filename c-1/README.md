# 1章 MySQLのアーキテクチャと歴史

- MySQLは他のデータベースサーバーとは違う
- アーキテクチャに特徴がある
- 柔軟
- MySQLの最も独特で重要な機能は、クエリ処理やその他のサーバータスクをデータの格納と取得から分離するように設計されたストレージエンジンアーキテクチャ

## 1.1 MySQLの論理アーキテクチャ

- 一番上のレイヤには接続処理/認証/セキュリティなどネットワークベースの殆どのクライアント/サーバーツールで必要となるサービス
- 2つめにはクリエ解析、分析、最適化、キャッシュ、組み込み関数、ストアドプロシージャ、トリガ、ビュー
- 3つめにはストレージエンジンが含まれる
    - MySQLの中に格納されているすべてのデータの保存と取得を受け持つ
    - サーバーはストレージエンジンAPIを通じてそれらとやりとりする
    - クエリレイヤでは見分けがつかなくなる

### 1.1.1 接続の管理とセキュリティ

- クライアント接続はそれぞれサーバープロセス内で独自のスレッドを取得する
- 接続のクエはその1つのスレッドで実行され、1つのコアまたはCPUと関連付けられる
- サーバーはスレッドをキャッシュする
    - 新しい接続のたびにスレッドの作成と削除を繰り返す必要はない
- クライアントがMySQLサーバーに接続するためにはサーバーが認証する必要がある
    - ユーザー名
    - 接続先ホスト
    - パスワード
    - SSL接続でX.509証明書を使用することもできる
    - クライアントが接続後に、サーバーはクライアントがworldデーターベースのCountryテーブルにSELECT文を送信する権限を持っているかどうかなど、クライアントがクエリに関する特権を持っているかどうかを確認する

### 1.1.2 最適化と実行

- MySQLはクエリを解析して内部構造を作成した後に、最適化を使用する
    - クエリの書き換え、テーブルを読み取る順序の決定、使用するインデックスの選択など
- クエリの特殊なキーワードを通じてオプティマイザにヒントを私、意思決定プロセスを反映させることもできる
- クエリ、スキーマ、設計を見直してすべてをできるだけ効率化するための基準点が得られる
- オプティマイザはどのテーブルがどのストレージエンジン使用するかについてはあまり関しがないが、ストレージエンジンはサーバーがクエリを最適化する方法に影響を与える
- オプティマイザはストレージエンジンの機能、特定の操作にかかるコスト、テーブルデータの統計をストレージエンジンに問い合わせる
- サーバーはクエリを解析する前であっても、SELECT文とそれらの結果セットだけが格納されるクエリキャッシュを調べる
- 送信されたクエリがすでにキャッシュに含まれるものと同じだった場合、キャッシュに格納されている結果セットを返すだけでよい

## 1.2 並行性の制御

- 複数のクエリがデータを同時に変更する必要が生じるたびに、並行性の制御が問題
- MySQLはサーバーレベルとストレージエンジンレベルの2つのレベルでそれを制御する必要がある

### 1.2.1 読み取り/書き込みロック

- 同時読み取り/書き込みアクセスに対処するシステムは2つの種類のロックシステムを実装する
    - 共有ロックと排他ロック、または読み取りロックと書き込みロック
- リソースの読み取りロックは共有されるまたは相互にノンブロッキング
    - 複数のクライアントがリソースを同時に読み取り、互いに干渉しない
- 書き込みロックは排他的
    - 読み取りロックと他の書き込みロックの両方をブロックする
- 常にリソースへの書き込みを行うクライアントを1つだけにし、書き込み中は読み取りを阻止するのが安全なポリシーだから

### 1.2.2 ロックの粒度

- 共有リソースの並行性を向上させる方法は、何をロックするかについて細かく選択する
    - 変更する必要があるデータが含まれている部分だけロック
    - 変更する予定のデータだけをロック
- ロックがリソースを消費する
    - ロックの取得
    - ロックが空いているかどうかのチェック
    - ロックの解除
- ロック戦略：ロックのオーバーヘッドとデータの安全性に折り合いをつけること
- ほとんどはテーブルでの行ロック
- MySQLは独自のロックポリシーとロック粒度を実装できる

**テーブルロック**

- 最も基本的で最もオーバーヘッドが低い
- テーブルに対して挿入、削除、更新などの書き込み操作を行いたいクライアントは書き込みロックを取得する
- 他の読み取り/書き込み操作はすべて拒否される
- 特定の状況でパフォーマンスを高めるバリエーション
    - READ LOCALテーブルロックは一種の同時書き込み操作を許可する
    - 書き込みロックは読み取りロックよりもキューの前方に配置される

**行ロック**

- 並行性、オーバーヘッドが最も高いロック方式
- InnoDBやXtraDBでも利用できる
- サーバーでなくてストレージエンジンで実装される
- サーバーはストレージエンジンで実装されるロックのことを何も知らない

## 1.2 トランザクション

- 1つの作業単位としてアトミックに扱われるSQLクエリの集まり
    - クエリ全体をデータベースに適用できる場合にはそうするが、クラッシュなどの理由で実行できないクエリがあればどのクエリも適用しない
- ACID
- アトミック姓
    - トランザクション全体が1つの分割できない作業単位として機能する
    - すべて完了するか、全て完了しないか
- 一貫性
    - 一つの一貫した状態から次の一貫した状態へ遷移すべき
- 分離性
    - トランザクションの結果はすべて完了するまで他のトランザクションからは見れない
- 永続性
    - コミットされたトランザクションの変更は確定される
    - 変更は記録される
- ACIDトランザクションに対応するデータベースサーバーはCPUパワー、メモリ、ディスク領域を必要とする
- 特定の種類のクエリにトランザクションに対応しないストレージエンジンを使用することでパフォーマンスを改善できるかもしれない

### 1.3.1 分離レベル

- SQL規格は4つの分離レベルを定義
- 分離レベルが低いほど並行性が高くなりオーバーヘッドが低くなる

**READ UNCOMMITTED**

- コミットされていないトランザクションの結果が他のトランザクションから見える
- いろいろな問題をはらんでいる
- 滅多に使われない
- ダーティリードとも呼ばれる

**READ COMMITED**

- ほとんどのRDBSのデフォルトの分離レベル
- トランザクションから見えるのはそれが開始された時にコミットされていたトランザクションによる変更だけ
- ノンリピータブルリードが許可
    - 同じステートメントを2回実行すると異なるデータが返される可能性がある

**REPEATABLE READ**

- トランザクションが読み取るすべての行が同じトランザクションのそれ以降の読み取りで同じに見えることが保証
- ファントムリードのも谷がある
    - ある範囲の行を選択した後、別のトランザクションがその範囲に新しい行を挿入し、その後に同じ範囲を再び選択したときに、新しい幻のファントムが現れる
- InnoDBとXtraDBはMVCCに基づいてファントムリードの問題を解決する
- MySQLのデフォルトのトランザクション分離レベルSERIALIZABLE

**SERIALIZABLE**

- 最も高いレベルの分離性
- 競合が怒らないようにトランザクションを強制的に順序付けて解決
- すべての読みとる行にロックを設定

### 1.3.2 デッドロック

- 複数のトランザクションが同じリソースのロックをめぐって競合し、それぞれのロックをリクエストして依存関係の循環を招くこと
- トランザクションが異なる順序でリソースをロックしようとしたとき
- InnoDBストレージエンジンなどの高度なシステムは循環依存を検知するとすぐにエラーを返す
- ロック待ちのタイムアウトが過ぎた時点でクエリの処理を断念しても、必ずしもよいとは限らない
- InnoDBは現在の排他ロックの数が最も少ないトランザクションをロールバックすることでデッドロックに対処している
- トランザクションを部分的または完全にロールバックしなければデッドロックは解除できない

### 1.3.3 トランザクションログ

- ストレージエンジンは変更が発生するたびにディスク上のテーブルを更新するのではなく、データのメモリ上のコピーを変更するだけでよい
- その後、ストレージエンジンの変更の記録をトランザクションログに書き込むことができる
    - ディスク上にあるため永続化できる
- ディスク上をあちこち飛び回るランダムI/Oではなく狭い範囲のシーケンシャルなI/Oが使用されるので、ログイベントの追加も比較的高速
- ログの先行書き込み
- トランザクションログに書き込まれたからデータ自体が変更されるまでの間にクラッシュしても、ストレージエンジンは再起動時に変更を取り戻すことができる

### 1.3.4 MySQLのトランザクション

- MySQLはInnoDBとNDB Clusterのトランザクショナルストレージエンジンを提供している

**AUTOCOMMIT**

- MySQLはデフォルトではAUTOCOMMIT
- クエリはそれぞれ別々のトランザクションで実行される
- AUTOCOMMITの値を変更しても、MyISAMやMemoryデーブルといった非トランザクショナルテーブルへの変更はない
- 実行中のトランザクションで発行するとMySQLがそのコマンドを実行する前にそのトランザクションをコミットするものがある
    - ALTER TABLEのような大幅な変更を行うDDL(Data Definition Language)コマンド
    - LOCK TABLE
- MySQLで分離レベルを設定するには`SET TRANSACTION ISOLATION LEVEL` コマンドを使用する

**トランザクションでの複数のストレージエンジンの併用**

- MySQLはトランザクションをサーバーレベルで管理しない
    - ストレージエンジンが管理
    - 複数のエンジンを1つのトランザクションで併用することが不可能
- トランザクショナルテーブルと非トランザクショナルテーブルがトランザクションに含まれている場合順当にいけばトランザクションは正常に処理される
- ロールバックが要求された場合、非トランザクショナルテーブルへの変更を取り消すことはできない
- MySQLは非トランザクショナルテーブルでトランザクション操作を行ったとしても通常は警告やエラーを生成しない

**暗黙的なロックと明示的なロック**

- InnoDBは2相のロックプロトコルを使用する
- トランザクションの実行中はいつでも使用できるが、`COMMIT`または`ROLLBACK`まで開放されない
- InnoDBはすべてのロックを同時に開放する
    - すべて暗黙的
    - 分離レベルに基づいてロックを自動的に処理する
- InnoDBは明示的なロックもサポート
    - SELECT ... LOCK IN SHARE MODE
    - SELECT ... FOR UPDATE
- ストレージエンジンではなくサーバー上で実装される
- MyISAMからInnoDBに変換されているものの依然としてLOCK TABLESを使用しているアプリケーションをよく見かける
    - 行レベルのロックなのでもはや不要で、パフォーマンスを劇的に低下させる可能性がある

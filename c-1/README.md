# 1章 MySQLのアーキテクチャと歴史

- MySQLは他のデータベースサーバーとは違う
- アーキテクチャに特徴がある
- 柔軟
- MySQLの最も独特で重要な機能は、クエリ処理やその他のサーバータスクをデータの格納と取得から分離するように設計されたストレージエンジンアーキテクチャ

## 1.1 MySQLの論理アーキテクチャ

- 一番上のレイヤには接続処理/認証/セキュリティなどネットワークベースの殆どのクライアント/サーバーツールで必要となるサービス
- 2つめにはクリエ解析、分析、最適化、キャッシュ、組み込み関数、ストアドプロシージャ、トリガ、ビュー
- 3つめにはストレージエンジンが含まれる
    - MySQLの中に格納されているすべてのデータの保存と取得を受け持つ
    - サーバーはストレージエンジンAPIを通じてそれらとやりとりする
    - クエリレイヤでは見分けがつかなくなる

### 1.1.1 接続の管理とセキュリティ

- クライアント接続はそれぞれサーバープロセス内で独自のスレッドを取得する
- 接続のクエはその1つのスレッドで実行され、1つのコアまたはCPUと関連付けられる
- サーバーはスレッドをキャッシュする
    - 新しい接続のたびにスレッドの作成と削除を繰り返す必要はない
- クライアントがMySQLサーバーに接続するためにはサーバーが認証する必要がある
    - ユーザー名
    - 接続先ホスト
    - パスワード
    - SSL接続でX.509証明書を使用することもできる
    - クライアントが接続後に、サーバーはクライアントがworldデーターベースのCountryテーブルにSELECT文を送信する権限を持っているかどうかなど、クライアントがクエリに関する特権を持っているかどうかを確認する

### 1.1.2 最適化と実行

- MySQLはクエリを解析して内部構造を作成した後に、最適化を使用する
    - クエリの書き換え、テーブルを読み取る順序の決定、使用するインデックスの選択など
- クエリの特殊なキーワードを通じてオプティマイザにヒントを私、意思決定プロセスを反映させることもできる
- クエリ、スキーマ、設計を見直してすべてをできるだけ効率化するための基準点が得られる
- オプティマイザはどのテーブルがどのストレージエンジン使用するかについてはあまり関しがないが、ストレージエンジンはサーバーがクエリを最適化する方法に影響を与える
- オプティマイザはストレージエンジンの機能、特定の操作にかかるコスト、テーブルデータの統計をストレージエンジンに問い合わせる
- サーバーはクエリを解析する前であっても、SELECT文とそれらの結果セットだけが格納されるクエリキャッシュを調べる
- 送信されたクエリがすでにキャッシュに含まれるものと同じだった場合、キャッシュに格納されている結果セットを返すだけでよい

## 1.2 並行性の制御

- 複数のクエリがデータを同時に変更する必要が生じるたびに、並行性の制御が問題
- MySQLはサーバーレベルとストレージエンジンレベルの2つのレベルでそれを制御する必要がある

### 1.2.1 読み取り/書き込みロック

- 同時読み取り/書き込みアクセスに対処するシステムは2つの種類のロックシステムを実装する
    - 共有ロックと排他ロック、または読み取りロックと書き込みロック
- リソースの読み取りロックは共有されるまたは相互にノンブロッキング
    - 複数のクライアントがリソースを同時に読み取り、互いに干渉しない
- 書き込みロックは排他的
    - 読み取りロックと他の書き込みロックの両方をブロックする
- 常にリソースへの書き込みを行うクライアントを1つだけにし、書き込み中は読み取りを阻止するのが安全なポリシーだから

### 1.2.2 ロックの粒度

- 共有リソースの並行性を向上させる方法は、何をロックするかについて細かく選択する
    - 変更する必要があるデータが含まれている部分だけロック
    - 変更する予定のデータだけをロック
- ロックがリソースを消費する
    - ロックの取得
    - ロックが空いているかどうかのチェック
    - ロックの解除
- ロック戦略：ロックのオーバーヘッドとデータの安全性に折り合いをつけること
- ほとんどはテーブルでの行ロック
- MySQLは独自のロックポリシーとロック粒度を実装できる

**テーブルロック**

- 最も基本的で最もオーバーヘッドが低い
- テーブルに対して挿入、削除、更新などの書き込み操作を行いたいクライアントは書き込みロックを取得する
- 他の読み取り/書き込み操作はすべて拒否される
- 特定の状況でパフォーマンスを高めるバリエーション
    - READ LOCALテーブルロックは一種の同時書き込み操作を許可する
    - 書き込みロックは読み取りロックよりもキューの前方に配置される

**行ロック**

- 並行性、オーバーヘッドが最も高いロック方式
- InnoDBやXtraDBでも利用できる
- サーバーでなくてストレージエンジンで実装される
- サーバーはストレージエンジンで実装されるロックのことを何も知らない

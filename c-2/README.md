# MySQLのベンチマーク

## 2.1 ベンチマークを実行する理由

- 負荷がかかってりうときのシステムの振る舞いを観察
- システムのキャパシティを特定
- どの変更が重要であるかを学習
- データを使ってアプリケーションの性能を調べるのに役立つ
- 実際には観察できない架空の状況を作り出せる

ベンチマークでできること

- システムに関する想定を検証し、現実的かどうかを確認
- 解決しようとしているシステムの不正な動作を再現
- アプリケーションの現在のパフォーマンスを計測する
    - 現在の実行速度がわからなければ、変更を加えたとしてもそれが役立つかどうかわからない
    - 過去のベンチマーク結果に基づいて予測していなかった問題を診断
- 実際の稼働環境のシステムが対応できる以上の負荷をシミュレートする
    - システムが成長したときに最初に遭遇するであろうスケーラビリティのボトルネックを特定
- 成長を予測
    - 予測される将来の負荷に必要なハードウェア、ネットワークキャパシティ、その他のリソースがどれくらいか見積もる
    - アップグレードやアプリケーションの大きな変更の際にリスクを低減する
- アプリケーションが環境の変化に対応できるかどうかテストする
    - 散発的なピークが同時に発生した場合のパフォーマンス
    - 別のサーバー設定でのアプリケーションのパフォーマンス
    - アプリケーションが異なるデータ分布をどう扱うか
- 専用のベンチマークでさまざまなハードウェア、ソフトウェア、オペレーティングシステム設定をテストする
    - RAID5とRAID10はどちらがシステムに適しているか
    - ATAディスクからSANストレージに切り替えた場合にランダム書き込みのパフォーマンスはどのように変化するか
    - Linuxの2.4カーネルは2.6カーネルよりもスケーラビリティがあるか
    - MySQLのアップグレードはパフォーマンスの改善に役立つか
    - データに別のストレージエンジンを使用するとどうなるか
- 購入したばかりのハードウェアが正しく設定されていることを確認する
    - ベンチマークを使って新しいシステムで稼働テストを行ったところ、設定上の間違いやハードウェアコンポーネントの不具合がみつかることはよくある
    - 新しいサーバーはベンチマーク実行してからでなければ実際の稼働環境に導入しないのが得策
    - 何がインストールされていて、パフォーマンスがどれくらいかに関して、ホスティングアプリケーションやハードウェアベンダーが言うことを鵜呑みにしてはならない
        - 常にテストを行う
- ベンチマークは現実のものではない
- システムにストレスをかけるためのワークロードは、現実のワークロードに比べてたいてい非常に単純
    - 現実のワークロードは不確定、変動しやすい、すぐには理解できないほど確実
    - システムのベンチマークに現実のワークロードを使用した場合、ベンチマーク結果から正確な結論を引き出すのはかえって難しくなるだろう
- ベンチマークにはデータのサイズやデータとクエリの分析など、人工的な部分がいろいろある
- もっとも重要なのは、ベンチマークが通常はできる限り高速に実行され、システムの正常な動作に支障をきたすほど負荷をかけること
    - 多くの場合は、ベンチマークツールを許容範囲ぎりぎりまで高速に実行し、適度なパフォーマンスを保てるように必要に応じてブレーキをかけることが望ましい
        - 特にシステムの最大有効キャパシティを判定するのに役立つ
    - ほとんどのベンチマークはそのような複雑な設定をサポートしていない
    - 結果の優位性と有効性がツールによって制限される
- キャパシティの計画にベンチマークを利用するのも難しい
    - ベンチマーク結果からの推定値は現実に即していない
    - ワークロード、データ、関係、機能における変化をシミュレートするのは難しく、影響を推測するのは容易ではない
- システムのキャパシティに適度な余裕があるかどうかを知ることを目的として、通常は概算値でよしとする
- 単純で、直接的な比較が可能で、実行コストが低く、実行しやすいのがベンチマーク
- ベンチマークには制限があるが、便利
- 自分が何をしてるのか、結果がどのように有意義なのか自覚できていればよい


## 2.2 ベンチマークの戦略

- フルスタックベンチマーク
    - アプリケーション全体のベンチマークを実行する
- 単一コンポーネントベンチマーク
    - MySQLを分離してベンチマークを実行する
- MySQLだけでなくアプリケーション全体を計測する理由
    - Webサーバー、アプリケーションコード、ネットワーク、データベースを含め、アプリケーション全体をテストする
        - アプリケーション全体としてどうであるか調べるのに役立つ
    - MySQLがアプリケーションのボトルネックであるとは限らない
    - 各部分のキャシュの振る舞いを調べるには、アプリケーション全体をテストするしかない
    - ベンチマークが意味を持つのは、実施あのアプリケーションの振る舞いが反映される範囲まで
        - アプリケーションの一部しかテストしないでベンチマークに意味をもたせるのは難しい
- アプリケーションのベンチマークを作成するのは簡単ではなく、正確に準備することすら難しい
- 少なくとも最初はMySQLのベンチマークがあれば十分かもしれない
    - さまざまなスキーマやクエリを比較したい
    - アプリケーションで確認された特定の問題をベンチマークしたい
    - 長いベンチマークでなく短いベンチマークを使って変更と計測の「サイクル時間」を短くしたい
- MySQLのベンチマークは実際のデータセットに対してアプリケーションのクエリを繰り返し実行できる場合にも役立つ
    - データ自体とデータセットのサイズはどちらも現実的なものでなければならない
    - できれば実際のデータのスナップショットが望ましい
- 現実的なベンチマークのセットアップは複雑で時間がかかることがある
    - アプリケーションが大きく成長したときのパフォーマンスを知りたい場合は、より大きなアプリケーションのデータとワークロードをシミュレートする以外にない

### 2.2.1 何を計測するか

- ベンチマーク前に目標を設定する
    - 「このCPUはそのCPUよりもよいか」
    - 「新しいインデックスは現在のものよりもうまく動作するか」
- 計測の対象ごとに異なる手法が必要となることもある

**スループット**

- 時間単位あたりのトランザクションの数
    - TPCC-Cなどの標準ベンチマーク

**応答時間または遅延**

- タスクに必要な合計時間
    - これをもとに応答の平均時間、最大時間、最小時間、パーセンタイル数などを割り出す
- 最大応答時間がメトリックとして役立つことは滅多に無い
    - ベンチマークを実行する時間が長くなるほど最大応答時間が長くなる可能性があるため
- 実行から次の実行までの感覚には大きなばらつきがあるため、まったく再現不可能
- パーセンタイル応答時間が使われる
- ベンチマーク結果を折れ線グラフ（平均と95パーセンタイルなど）または散布図にし、結果の分析状況を確認できるようにする

**並行性**

- 重要だが、メトリックとして誤って使用されることや、よく理解されていないことが多い
- 例えば、Webサイトにアクセスしているユーザーの数
    - 通常はセッション数で計測される
    - だた、HTTPはステートレス
    - ほとんどのユーザーは各自のブラウザに表示されたものを読んでいるだけ
    - Webサーバーの並行性であるとは解釈されない
    - Webサーバー上での並行性がデータベースサーバーに当てはまるとは限らない
        - セッションにおいてストレージメカニズムが処理しなければならないデータの量だけ
    - 同時に発生するリクエストの数を計測するほうが的を得ている
- Webサーバーの並行性とデータベースレベルの並行性は等価ではない
    - 言語とツールセットに左右される
    - データベースサーバーへ開いている接続と並行性と混同しないように中ウイ
    - アプリケーションがうまく設計されていれば、MySQLサーバーとの間で何百もの接続を開いていたとしても、クエリを実行している接続はごく一部
- ベンチマークで本当に注意しなければいけないのは実際の並行性
    - 同時に作業を行うスレッドや接続の数
    - 並行性が高くなったときにスループットが低下したり応答時間が長くなったりしていないか
- 並行性は結果ではなく、ベンチマークのセットアップ方法の特性
    - アプリケーションが達成する並行性を計測するのではなく、通常はベンチマークツールに様々なレベルの並行性を再現させた上で、アプリケーションのパフォーマンスを測定することになる
    - ただしデータベースでも並行性を計測すべき
        - スレッド数を32,64,128に設定してSysBenchを実行し、それぞれの実行時にデータベースサーバーをチェックし、Threads_running状態変数の値を記録する

**スケーラビリティ**

- 変動的なワークロードのもとでパフォーマンスを維持する必要があるシステムに役立つ
- タスクを完了しようとするワーカーの数を2倍にすれば、作業量（スループット）も2倍になるのが理想的なシステム
    - CPUを2倍にするなど、利用可能なリソースを2倍にすれば、スループットも2倍になるはず
- ほとんどのシステムのスケーラビリティは直線的ではない
    - パラメータを変化させれば応答が低下し、パフォーマンスの低下を招く
- スケーラビリティの計測は他のベンチマーク戦略では示されないアプリケーションの弱点を明らかにすることから、キャパシティの計画に役立つ
- 応答時間のベンチマーク結果がよいのは接続が1つの場合という安直なベンチマーク戦略でシステム設計した場合、並行処理が少しでも発生すればアプリケーションのパフォーマンスが低下するかも知れない
- 接続の数を増やした状態で一貫した応答時間を期待するベンチマークは、この設計上の欠陥を明らかにするだろう
- 詳細データからサマリテーブルを作成するバッチジョブなどは応答時間が短ければそれで十分
- 本当の応答時間をベンチマークするのもいいが、それらが他のアクティビティにどのような影響を与えるのか考えるのも忘れないで
- バッチジョブは対話型クエリの実行を遅らせる可能性があり、逆もまた同様

- 最終分析では、ユーザーにとって重要なことをベンチマークする必要がある
    - 応答時間がどらくれいなら許されるか
    - どのような種類の並行性を期待するか
    - 公式/非公式の要件を集める
    - 単視眼的になったり何かにこだわってほかを排除したりせずに、すべての要件を満たすようなベンチマークの設計を心がけるようにする

## 2.3 ベンチマークの戦術

- 一般的な間違い
    - 実施のデータサイズの一部しか使用していない
        - 数百ギガバイトのデータを処理しなければならないアプリケーションでたった1ギガバイトのデータしか使用しない、あるいは大幅な成長が見込まれているアプリケーションで現在のデータセットを使用するなど
    - 不正確に分散されたデータを使用している
    - 非現実的に分散されたパラメータを使用している
    - マルチユーザーアプリケーションに対してシングルユーザーのシナリオを使用している
    - 1台のサーバー上で分散アプリケーションのベンチマークを使用している
    - Webページの思考時間などが現実のユーザーの振る舞いを一致していない
    →現実のユーザーは、ページをリクエストしてそれを読むため、間髪入れずにリンクをクリックしない
    - ループを使って全く同じクエリを実行する
    →現実のクエリは全く同じではないため、キャッシュミスを引き起こす
    - エラーのチェックを怠っている
    →ベンチマークの結果が意味をなさないときはエラーをチェックする
        - ベンチマークの後は必ずエラーログをチェックすること
    - リブートの直後であるなど、システムのウォームアップが完了していないときのパフォーマンスを無視している
    →ウォームアップ時間は具体的に調べたほうがよい
        - リブート直後のベンチマークでは多くのキャッシュがコールドとなり、キャッシュがウォームアップしているときの負荷で得られるはずの結果がベンチマークに反映されない
    - デフォルトのサーバー設定を使用している
    →サーバーは最適化させる必要がある
    - ベンチマークの時間が短すぎる
    →ベンチマークはしばらく実行し続ける必要がある
- これらの誤りを避けるだけで結果の品質の向上に大きく役立つ
- 通常はテストができるだけ現実的なものになるように努力すべき
- 少し非現実的なベンチマークを使用するとよいこと
    - アプリケーションがデータベースサーバーと別のホストで実行される
        - 同じ構成でベンチマークを実行するほうが現実だが、ネットワーク速度や負荷といった変数が追加される
        - 1つのノードでベンチマークするほうが通常は楽で、十分な場合も

### 2.3.1 ベンチマークの設計と計画

- 問題と目標を洗い出す
- 標準のベンチマークを使用するのか、独自に設定するのか決定する
    - 標準のベンチマークを使用する場合、ニーズに適合するものを選択する
    - カスタムベンチマークの設計は、複雑で繰り返しの多いプロセス
        - 実際の稼働環境のデータセットのスナップショットを作成する
- データに対して実行するクエリを用意する
    - ユニットテストスイートを何度か実行するだけで基本的なベンチマークは作成できる
    - それがデータベースの現実的な使用法と一致する可能性は低い
    - ピーク時やまる一日といった代表的な時間枠で、実際の稼働環境のシステム上で実行されるクエリをすべて記録するほうがよい
        - 週報クエリやピーク時以外の時間帯にスケジュールされるパッチジョブなど、すべてのシステムアクティビティをカバーできる
- クエリは様々なレベルで記録できる
    - フルスタックベンチマークが必要な場合はWebサーバー上でHTTPリクエストを記録する
- カスタムベンチマークを作成しない場合でも、ベンチマークプランを作成すべき
    - ベンチマークは繰り返し実行されるので正確に再現されるべき
    - テストデータ、システムのセットアップ手順、結果を計測して分析する方法、ウォームアッププラン
- パラメータと結果を文書化する方法を設計し、実行をその都度綿密に記録すること

### 2.3.2 ベンチマークを実行する時間の長さ

- ベンチマークの実行時間は十分なものでなければならない
- システムの定常状態は定常状態のシステムを観察する必要がある
- ほとんどのシステムにはバースタブルキャパ七日を可能にするためのバッファがある
    - 一部の処理を先送りにすることでスパイク緩和し、ピーク時の遅れを取り戻す機能のこと
    - 長時間になってストレスにさらされると限界を超えてしまい、短絡的なピークパフォーマンスすら維持できなくなる
- ベンチマークを実行したままにして、システムが安定し始めたことが確認できるまで観察するとよい
- 非常によくある間違い
    - 短いベンチマークをいくつか実行し、その結果からシステムのパフォーマンスに関して結論を引き出そうとする

### 2.3.3 システムのパフォーマンスとステータスを補足する

- テストの対象となるシステム(SUI)に関する情報をできるだけ集める
- ベンチマーク用のディレクトリと実行ごとに結果を保存するサブディレクトリを作成しておく
    - なるべくデータをすべて残しておく

```bash
#! /bin/sh

INTEARVAL=5
PREFIX=$INTERVAL-sec-status
RUNFILE=/home/benchmarks/running
mysql -e 'SHOW GLOBAL VARIABLES' >> mysql-variables
while test -e $RUNFILE; do
	file=$(data +%F_%I)
	sleep=$(data + %s.%N | awk "{print $INTERVAL - (\$1 % $INTERVAL) }")
	sleep= $sleep
	ts="$(data + "TS %s.%N %F %T")"
	loadavg="$(uptime)"
	echo "$ts $loadavg" >> $PREFIX-$(file)-status
	mysql -e 'SHOW GLOBAL STATUS' >> $PREFIX-$(file)-status &
	echo "$ts $loadavg >> $PREFIX-$(file)-innodbstatus
	mysql -e 'SHOW GLOBAL STATUS' >> $PREFIX-$(file)-innodbstatus &
	echo "$ts $loadavg >> $PREFIX-$(file)-processlist
	mysql -e "$ts $loadavg" >> $PREFIX-$(file)-processlist &
	echo &ts
done
echo Exiting because $RUNTIME does not exist.
```

- イテレーションの感覚が指定されている
    - 5秒
- ベンチマークの実行日時に併せてファイルが分割される
- それぞれ別のタイムスタンプ行で始まる
- 収集したデータの前処理やフィルタリングは行わない
- ベンチマークが完了したときにスクリプトを終了させることができる

### 2.3.4 正確な結果を記録する

- 正確な結果を得るためには、ほしい答えを得られるようなベンチマークを設計することが肝心である
- ベンチマークの結果が再現可能であることを確認する
    - ベンチマークの実行を開始するたびにシステムの初期状態が同じになるようにする
    - 実行のたびにリブート
    - ウォームアップ済のサーバーでベンチマークを実行する
- スキーマを変更する場合は、実行のたびに新しいスナップショットをセットする
    - 物理的なレイアウトをほぼ同じにする方法：パーティションのクイックフォーマットとファイルのコピーを実行する
- 外部の負荷、システムのプロファイリングと監視、冗長なログ、定期的なジョブなどの要因にも注意する
- ベンチマークを実行するたびに変更するパラメータの数はできるだけ少なくする
- パラメータを段階的に変更していく方が通常は効果的
- 移行後のパフォーマンスを予想しようとするベンチマークもたくさんある
    - OracleからMySQLとか
- MySQLのデフォルト設定はメモリにおほんのわずかしか消費しない小さなアプリケーションに合わせて調整されている
- ソリッドステートストレージにはベンチマークに対して課題がある
- おかしな結果が出たとしても、不適切なデータポイントとして集めたり、わからないままにしておいてはならない

### 2.3.5 ベンチマークを実行し、結果を分析する

- ベンチマークの実行を自動化するのは良い考え
    - 実行のたびに違うことをしてしまわない
    - 手順を忘れてしまうことがない
- 自動化の方法はMakefileでも、カスタムスクリプトでも構わない
- データの読み込み、システムのバックアップ、ベンチマークの実行、結果の記録をできるだけ自動化する
- 通常はベンチマークは数回にわたって実行する
- もっともよい結果を求める場合の常套手段は、すべての結果を平均化するか、ベンチマークを5回実行し、そのうち最も良い3つの結果を平均することである
- 結果が手に入ったらそれらを分析する
    - CPUを4つに増やすと同じ応答時間でスループットが50パーセント向上する
    - インデックスによりクエリが高速になった
- 科学的な答えがほしい場合には帰無仮説について調べてみる
- 「計算」方法は結果を集める方法によって決まる
    - 結果分析のためのスクリプトを記述する必要がある
    - 必要な作業量を減らすためではなく、再現性と文書化のため
- データ収集スクリプトから時系列で計測値を抽出するのに役立つ、非常に単純なシェルスクリプト

```bash
#! bin/sh

# このスクリプトはSHOW GLOBAL STATUSをタブで区切られた形式に変換する
# 入力のサンプルごとに1行が割当られ、
# 計測値はサンプルとサンプルの間隔によって分割される
awk '
	BEGIN {
    printf "#ts date time load QPS";
    fmt = " %.2f";
  }
  /^TS/ { # タイムスタンプ行はTSで始まる
    ts = substr($2, 1, index($2, ".") - 1);
    load = NF - 2;
    diff = ts - prev_ts;
    prev_ts = ts;
    printf "\n%s %s %s %s", substr($load, 1, length($load)-1);
  }
  /Queries/ {
    printf fmt, ($2-Queries)/diff;
    Queries=$2;
  }
' "$@" 
```
